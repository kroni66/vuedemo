import { defineComponent as P, openBlock as j, createBlock as x, resolveDynamicComponent as A, normalizeProps as C, guardReactiveProps as M, ref as N, onMounted as I } from "vue";
import q from "axios";
var L = Object.defineProperty, z = Object.defineProperties, B = Object.getOwnPropertyDescriptors, b = Object.getOwnPropertySymbols, D = Object.prototype.hasOwnProperty, U = Object.prototype.propertyIsEnumerable, v = (o, t, e) => t in o ? L(o, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : o[t] = e, h = (o, t) => {
  for (var e in t || (t = {}))
    D.call(t, e) && v(o, e, t[e]);
  if (b)
    for (var e of b(t))
      U.call(t, e) && v(o, e, t[e]);
  return o;
}, y = (o, t) => z(o, B(t));
let _ = !1;
const T = [], V = (o) => new Promise((t, e) => {
  if (typeof window > "u" || (window.storyblokRegisterEvent = (s) => {
    if (window.location === window.parent.location) {
      console.warn("You are not in Draft Mode or in the Visual Editor.");
      return;
    }
    _ ? s() : T.push(s);
  }, document.getElementById("storyblok-javascript-bridge")))
    return;
  const r = document.createElement("script");
  r.async = !0, r.src = o, r.id = "storyblok-javascript-bridge", r.onerror = (s) => e(s), r.onload = (s) => {
    T.forEach((n) => n()), _ = !0, t(s);
  }, document.getElementsByTagName("head")[0].appendChild(r);
}), H = function(o, t) {
  if (!o)
    return null;
  let e = {};
  for (let r in o) {
    let s = o[r];
    t.indexOf(r) > -1 && s !== null && (e[r] = s);
  }
  return e;
}, J = (o) => o === "email";
var Y = {
  nodes: {
    horizontal_rule() {
      return {
        singleTag: "hr"
      };
    },
    blockquote() {
      return {
        tag: "blockquote"
      };
    },
    bullet_list() {
      return {
        tag: "ul"
      };
    },
    code_block(o) {
      return {
        tag: [
          "pre",
          {
            tag: "code",
            attrs: o.attrs
          }
        ]
      };
    },
    hard_break() {
      return {
        singleTag: "br"
      };
    },
    heading(o) {
      return {
        tag: `h${o.attrs.level}`
      };
    },
    image(o) {
      return {
        singleTag: [
          {
            tag: "img",
            attrs: H(o.attrs, ["src", "alt", "title"])
          }
        ]
      };
    },
    list_item() {
      return {
        tag: "li"
      };
    },
    ordered_list() {
      return {
        tag: "ol"
      };
    },
    paragraph() {
      return {
        tag: "p"
      };
    }
  },
  marks: {
    bold() {
      return {
        tag: "b"
      };
    },
    strike() {
      return {
        tag: "strike"
      };
    },
    underline() {
      return {
        tag: "u"
      };
    },
    strong() {
      return {
        tag: "strong"
      };
    },
    code() {
      return {
        tag: "code"
      };
    },
    italic() {
      return {
        tag: "i"
      };
    },
    link(o) {
      const t = h({}, o.attrs), { linktype: e = "url" } = o.attrs;
      return J(e) && (t.href = `mailto:${t.href}`), t.anchor && (t.href = `${t.href}#${t.anchor}`, delete t.anchor), {
        tag: [
          {
            tag: "a",
            attrs: t
          }
        ]
      };
    },
    styled(o) {
      return {
        tag: [
          {
            tag: "span",
            attrs: o.attrs
          }
        ]
      };
    }
  }
};
const F = function(o) {
  const t = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  }, e = /[&<>"']/g, r = RegExp(e.source);
  return o && r.test(o) ? o.replace(e, (s) => t[s]) : o;
};
class R {
  constructor(t) {
    t || (t = Y), this.marks = t.marks || [], this.nodes = t.nodes || [];
  }
  addNode(t, e) {
    this.nodes[t] = e;
  }
  addMark(t, e) {
    this.marks[t] = e;
  }
  render(t = {}) {
    if (t.content && Array.isArray(t.content)) {
      let e = "";
      return t.content.forEach((r) => {
        e += this.renderNode(r);
      }), e;
    }
    return console.warn("The render method must receive an object with a content field, which is an array"), "";
  }
  renderNode(t) {
    let e = [];
    t.marks && t.marks.forEach((s) => {
      const n = this.getMatchingMark(s);
      n && e.push(this.renderOpeningTag(n.tag));
    });
    const r = this.getMatchingNode(t);
    return r && r.tag && e.push(this.renderOpeningTag(r.tag)), t.content ? t.content.forEach((s) => {
      e.push(this.renderNode(s));
    }) : t.text ? e.push(F(t.text)) : r && r.singleTag ? e.push(this.renderTag(r.singleTag, " /")) : r && r.html && e.push(r.html), r && r.tag && e.push(this.renderClosingTag(r.tag)), t.marks && t.marks.slice(0).reverse().forEach((s) => {
      const n = this.getMatchingMark(s);
      n && e.push(this.renderClosingTag(n.tag));
    }), e.join("");
  }
  renderTag(t, e) {
    return t.constructor === String ? `<${t}${e}>` : t.map((s) => {
      if (s.constructor === String)
        return `<${s}${e}>`;
      {
        let n = `<${s.tag}`;
        if (s.attrs)
          for (let a in s.attrs) {
            let i = s.attrs[a];
            i !== null && (n += ` ${a}="${i}"`);
          }
        return `${n}${e}>`;
      }
    }).join("");
  }
  renderOpeningTag(t) {
    return this.renderTag(t, "");
  }
  renderClosingTag(t) {
    return t.constructor === String ? `</${t}>` : t.slice(0).reverse().map((r) => r.constructor === String ? `</${r}>` : `</${r.tag}>`).join("");
  }
  getMatchingNode(t) {
    if (typeof this.nodes[t.type] == "function")
      return this.nodes[t.type](t);
  }
  getMatchingMark(t) {
    if (typeof this.marks[t.type] == "function")
      return this.marks[t.type](t);
  }
}
/*!
 * storyblok-js-client v4.5.2
 * Universal JavaScript SDK for Storyblok's API
 * (c) 2020-2022 Stobylok Team
 */
function w(o) {
  return typeof o == "number" && o == o && o !== 1 / 0 && o !== -1 / 0;
}
function $(o, t, e) {
  if (!w(t))
    throw new TypeError("Expected `limit` to be a finite number");
  if (!w(e))
    throw new TypeError("Expected `interval` to be a finite number");
  var r = [], s = [], n = 0, a = function() {
    n++;
    var c = setTimeout(function() {
      n--, r.length > 0 && a(), s = s.filter(function(u) {
        return u !== c;
      });
    }, e);
    s.indexOf(c) < 0 && s.push(c);
    var l = r.shift();
    l.resolve(o.apply(l.self, l.args));
  }, i = function() {
    var c = arguments, l = this;
    return new Promise(function(u, p) {
      r.push({ resolve: u, reject: p, args: c, self: l }), n < t && a();
    });
  };
  return i.abort = function() {
    s.forEach(clearTimeout), s = [], r.forEach(function(c) {
      c.reject(new throttle.AbortError());
    }), r.length = 0;
  }, i;
}
$.AbortError = function() {
  Error.call(this, "Throttled function aborted"), this.name = "AbortError";
};
const K = function(o, t) {
  if (!o)
    return null;
  let e = {};
  for (let r in o) {
    let s = o[r];
    t.indexOf(r) > -1 && s !== null && (e[r] = s);
  }
  return e;
};
var G = { nodes: { horizontal_rule: () => ({ singleTag: "hr" }), blockquote: () => ({ tag: "blockquote" }), bullet_list: () => ({ tag: "ul" }), code_block: (o) => ({ tag: ["pre", { tag: "code", attrs: o.attrs }] }), hard_break: () => ({ singleTag: "br" }), heading: (o) => ({ tag: `h${o.attrs.level}` }), image: (o) => ({ singleTag: [{ tag: "img", attrs: K(o.attrs, ["src", "alt", "title"]) }] }), list_item: () => ({ tag: "li" }), ordered_list: () => ({ tag: "ol" }), paragraph: () => ({ tag: "p" }) }, marks: { bold: () => ({ tag: "b" }), strike: () => ({ tag: "strike" }), underline: () => ({ tag: "u" }), strong: () => ({ tag: "strong" }), code: () => ({ tag: "code" }), italic: () => ({ tag: "i" }), link(o) {
  const t = h({}, o.attrs), { linktype: e = "url" } = o.attrs;
  return e === "email" && (t.href = `mailto:${t.href}`), t.anchor && (t.href = `${t.href}#${t.anchor}`, delete t.anchor), { tag: [{ tag: "a", attrs: t }] };
}, styled: (o) => ({ tag: [{ tag: "span", attrs: o.attrs }] }) } };
class Q {
  constructor(t) {
    t || (t = G), this.marks = t.marks || [], this.nodes = t.nodes || [];
  }
  addNode(t, e) {
    this.nodes[t] = e;
  }
  addMark(t, e) {
    this.marks[t] = e;
  }
  render(t = {}) {
    if (t.content && Array.isArray(t.content)) {
      let e = "";
      return t.content.forEach((r) => {
        e += this.renderNode(r);
      }), e;
    }
    return console.warn("The render method must receive an object with a content field, which is an array"), "";
  }
  renderNode(t) {
    let e = [];
    t.marks && t.marks.forEach((s) => {
      const n = this.getMatchingMark(s);
      n && e.push(this.renderOpeningTag(n.tag));
    });
    const r = this.getMatchingNode(t);
    return r && r.tag && e.push(this.renderOpeningTag(r.tag)), t.content ? t.content.forEach((s) => {
      e.push(this.renderNode(s));
    }) : t.text ? e.push(function(s) {
      const n = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, a = /[&<>"']/g, i = RegExp(a.source);
      return s && i.test(s) ? s.replace(a, (c) => n[c]) : s;
    }(t.text)) : r && r.singleTag ? e.push(this.renderTag(r.singleTag, " /")) : r && r.html && e.push(r.html), r && r.tag && e.push(this.renderClosingTag(r.tag)), t.marks && t.marks.slice(0).reverse().forEach((s) => {
      const n = this.getMatchingMark(s);
      n && e.push(this.renderClosingTag(n.tag));
    }), e.join("");
  }
  renderTag(t, e) {
    return t.constructor === String ? `<${t}${e}>` : t.map((r) => {
      if (r.constructor === String)
        return `<${r}${e}>`;
      {
        let s = `<${r.tag}`;
        if (r.attrs)
          for (let n in r.attrs) {
            let a = r.attrs[n];
            a !== null && (s += ` ${n}="${a}"`);
          }
        return `${s}${e}>`;
      }
    }).join("");
  }
  renderOpeningTag(t) {
    return this.renderTag(t, "");
  }
  renderClosingTag(t) {
    return t.constructor === String ? `</${t}>` : t.slice(0).reverse().map((e) => e.constructor === String ? `</${e}>` : `</${e.tag}>`).join("");
  }
  getMatchingNode(t) {
    if (typeof this.nodes[t.type] == "function")
      return this.nodes[t.type](t);
  }
  getMatchingMark(t) {
    if (typeof this.marks[t.type] == "function")
      return this.marks[t.type](t);
  }
}
const W = (o = 0, t = o) => {
  const e = Math.abs(t - o) || 0, r = o < t ? 1 : -1;
  return ((s = 0, n) => [...Array(s)].map(n))(e, (s, n) => n * r + o);
}, k = (o, t, e) => {
  const r = [];
  for (const s in o) {
    if (!Object.prototype.hasOwnProperty.call(o, s))
      continue;
    const n = o[s], a = e ? "" : encodeURIComponent(s);
    let i;
    i = typeof n == "object" ? k(n, t ? t + encodeURIComponent("[" + a + "]") : a, Array.isArray(n)) : (t ? t + encodeURIComponent("[" + a + "]") : a) + "=" + encodeURIComponent(n), r.push(i);
  }
  return r.join("&");
};
let f = {}, d = {};
class X {
  constructor(t, e) {
    if (!e) {
      let n = t.region ? `-${t.region}` : "", a = t.https === !1 ? "http" : "https";
      e = t.oauthToken === void 0 ? `${a}://api${n}.storyblok.com/v2` : `${a}://api${n}.storyblok.com/v1`;
    }
    let r = Object.assign({}, t.headers), s = 5;
    t.oauthToken !== void 0 && (r.Authorization = t.oauthToken, s = 3), t.rateLimit !== void 0 && (s = t.rateLimit), this.richTextResolver = new Q(t.richTextSchema), typeof t.componentResolver == "function" && this.setComponentResolver(t.componentResolver), this.maxRetries = t.maxRetries || 5, this.throttle = $(this.throttledRequest, s, 1e3), this.accessToken = t.accessToken, this.relations = {}, this.links = {}, this.cache = t.cache || { clear: "manual" }, this.client = q.create({ baseURL: e, timeout: t.timeout || 0, headers: r, proxy: t.proxy || !1 }), t.responseInterceptor && this.client.interceptors.response.use((n) => t.responseInterceptor(n)), this.resolveNestedRelations = t.resolveNestedRelations || !0;
  }
  setComponentResolver(t) {
    this.richTextResolver.addNode("blok", (e) => {
      let r = "";
      return e.attrs.body.forEach((s) => {
        r += t(s.component, s);
      }), { html: r };
    });
  }
  parseParams(t = {}) {
    return t.version || (t.version = "published"), t.token || (t.token = this.getToken()), t.cv || (t.cv = d[t.token]), Array.isArray(t.resolve_relations) && (t.resolve_relations = t.resolve_relations.join(",")), t;
  }
  factoryParamOptions(t, e = {}) {
    return ((r = "") => r.indexOf("/cdn/") > -1)(t) ? this.parseParams(e) : e;
  }
  makeRequest(t, e, r, s) {
    const n = this.factoryParamOptions(t, ((a = {}, i = 25, c = 1) => y(h({}, a), { per_page: i, page: c }))(e, r, s));
    return this.cacheResponse(t, n);
  }
  get(t, e) {
    let r = `/${t}`;
    const s = this.factoryParamOptions(r, e);
    return this.cacheResponse(r, s);
  }
  async getAll(t, e = {}, r) {
    const s = e.per_page || 25, n = `/${t}`, a = n.split("/");
    r = r || a[a.length - 1];
    const i = await this.makeRequest(n, e, s, 1), c = Math.ceil(i.total / s);
    return ((l = [], u) => l.map(u).reduce((p, O) => [...p, ...O], []))([i, ...await (async (l = [], u) => Promise.all(l.map(u)))(W(1, c), async (l) => this.makeRequest(n, e, s, l + 1))], (l) => Object.values(l.data[r]));
  }
  post(t, e) {
    let r = `/${t}`;
    return this.throttle("post", r, e);
  }
  put(t, e) {
    let r = `/${t}`;
    return this.throttle("put", r, e);
  }
  delete(t, e) {
    let r = `/${t}`;
    return this.throttle("delete", r, e);
  }
  getStories(t) {
    return this.get("cdn/stories", t);
  }
  getStory(t, e) {
    return this.get(`cdn/stories/${t}`, e);
  }
  setToken(t) {
    this.accessToken = t;
  }
  getToken() {
    return this.accessToken;
  }
  _cleanCopy(t) {
    return JSON.parse(JSON.stringify(t));
  }
  _insertLinks(t, e) {
    const r = t[e];
    r && r.fieldtype == "multilink" && r.linktype == "story" && typeof r.id == "string" && this.links[r.id] ? r.story = this._cleanCopy(this.links[r.id]) : r && r.linktype === "story" && typeof r.uuid == "string" && this.links[r.uuid] && (r.story = this._cleanCopy(this.links[r.uuid]));
  }
  _insertRelations(t, e, r) {
    if (r.indexOf(t.component + "." + e) > -1) {
      if (typeof t[e] == "string")
        this.relations[t[e]] && (t[e] = this._cleanCopy(this.relations[t[e]]));
      else if (t[e].constructor === Array) {
        let s = [];
        t[e].forEach((n) => {
          this.relations[n] && s.push(this._cleanCopy(this.relations[n]));
        }), t[e] = s;
      }
    }
  }
  _insertAssetsRelations(t, e) {
    e.forEach((r) => {
      t.id === r.id && (t.original = r, t.original.filename = t.filename, t.original.filename = t.original.filename.includes("https://s3.amazonaws.com/") ? t.original.filename : t.original.filename.replace("https://", "https://s3.amazonaws.com/"), delete t.original.s3_filename);
    });
  }
  iterateTree(t, e) {
    let r = (s) => {
      if (s != null) {
        if (s.constructor === Array)
          for (let n = 0; n < s.length; n++)
            r(s[n]);
        else if (s.constructor === Object) {
          if (s._stopResolving)
            return;
          for (let n in s)
            s.component && s._uid || s.type === "link" ? (this._insertRelations(s, n, e), this._insertLinks(s, n)) : "id" in s && s.fieldtype === "asset" && this._insertAssetsRelations(s, e), r(s[n]);
        }
      }
    };
    r(t.content);
  }
  async resolveLinks(t, e) {
    let r = [];
    if (t.link_uuids) {
      const s = t.link_uuids.length;
      let n = [];
      const a = 50;
      for (let i = 0; i < s; i += a) {
        const c = Math.min(s, i + a);
        n.push(t.link_uuids.slice(i, c));
      }
      for (let i = 0; i < n.length; i++)
        (await this.getStories({ per_page: a, language: e.language, version: e.version, by_uuids: n[i].join(",") })).data.stories.forEach((c) => {
          r.push(c);
        });
    } else
      r = t.links;
    r.forEach((s) => {
      this.links[s.uuid] = y(h({}, s), { _stopResolving: !0 });
    });
  }
  async resolveRelations(t, e) {
    let r = [];
    if (t.rel_uuids) {
      const s = t.rel_uuids.length;
      let n = [];
      const a = 50;
      for (let i = 0; i < s; i += a) {
        const c = Math.min(s, i + a);
        n.push(t.rel_uuids.slice(i, c));
      }
      for (let i = 0; i < n.length; i++)
        (await this.getStories({ per_page: a, language: e.language, version: e.version, by_uuids: n[i].join(",") })).data.stories.forEach((c) => {
          r.push(c);
        });
    } else
      r = t.rels;
    r.forEach((s) => {
      this.relations[s.uuid] = y(h({}, s), { _stopResolving: !0 });
    });
  }
  async resolveStories(t, e) {
    let r = [];
    if (e.resolve_relations !== void 0 && e.resolve_relations.length > 0 && (t.rels || t.rel_uuids) && (r = e.resolve_relations.split(","), await this.resolveRelations(t, e)), ["1", "story", "url"].indexOf(e.resolve_links) > -1 && (t.links || t.link_uuids) && await this.resolveLinks(t, e), this.resolveNestedRelations)
      for (const s in this.relations)
        this.iterateTree(this.relations[s], r);
    t.story ? this.iterateTree(t.story, r) : t.stories.forEach((s) => {
      this.iterateTree(s, r);
    });
  }
  resolveAssetsRelations(t) {
    const { assets: e, stories: r, story: s } = t;
    if (r)
      for (const n of r)
        this.iterateTree(n, e);
    else {
      if (!s)
        return t;
      this.iterateTree(s, e);
    }
  }
  cacheResponse(t, e, r) {
    return r === void 0 && (r = 0), new Promise(async (s, n) => {
      let a = k({ url: t, params: e }), i = this.cacheProvider();
      if (this.cache.clear === "auto" && e.version === "draft" && await this.flushCache(), e.version === "published" && t != "/cdn/spaces/me") {
        const l = await i.get(a);
        if (l)
          return s(l);
      }
      try {
        let l = await this.throttle("get", t, { params: e, paramsSerializer: (p) => k(p) }), u = { data: l.data, headers: l.headers };
        if (u.data.assets && u.data.assets.length && this.resolveAssetsRelations(u.data), l.headers["per-page"] && (u = Object.assign({}, u, { perPage: parseInt(l.headers["per-page"]), total: parseInt(l.headers.total) })), l.status != 200)
          return n(l);
        (u.data.story || u.data.stories) && await this.resolveStories(u.data, e), e.version === "published" && t != "/cdn/spaces/me" && i.set(a, u), u.data.cv && (e.version == "draft" && d[e.token] != u.data.cv && this.flushCache(), d[e.token] = u.data.cv), s(u);
      } catch (l) {
        if (l.response && l.response.status === 429 && (r += 1) < this.maxRetries)
          return console.log(`Hit rate limit. Retrying in ${r} seconds.`), await (c = 1e3 * r, new Promise((u) => setTimeout(u, c))), this.cacheResponse(t, e, r).then(s).catch(n);
        n(l);
      }
      var c;
    });
  }
  throttledRequest(t, e, r) {
    return this.client[t](e, r);
  }
  cacheVersions() {
    return d;
  }
  cacheVersion() {
    return d[this.accessToken];
  }
  setCacheVersion(t) {
    this.accessToken && (d[this.accessToken] = t);
  }
  cacheProvider() {
    return this.cache.type === "memory" ? { get: (t) => f[t], getAll: () => f, set(t, e) {
      f[t] = e;
    }, flush() {
      f = {};
    } } : { get() {
    }, getAll() {
    }, set() {
    }, flush() {
    } };
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this;
  }
}
const at = (o = {}) => {
  const { apiOptions: t } = o;
  if (!t.accessToken) {
    console.error("You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication");
    return;
  }
  return { storyblokApi: new X(t) };
};
var Z = (o) => {
  if (typeof o != "object" || typeof o._editable > "u")
    return {};
  const t = JSON.parse(o._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, ""));
  return {
    "data-blok-c": JSON.stringify(t),
    "data-blok-uid": t.id + "-" + t.uid
  };
};
let m;
const tt = "https://app.storyblok.com/f/storyblok-v2-latest.js", et = (o, t, e = {}) => {
  if (!(typeof window > "u")) {
    if (typeof window.storyblokRegisterEvent > "u") {
      console.error("Storyblok Bridge is disabled. Please enable it to use it. Read https://github.com/storyblok/storyblok-js");
      return;
    }
    if (!o) {
      console.warn("Story ID is not defined. Please provide a valid ID.");
      return;
    }
    window.storyblokRegisterEvent(() => {
      new window.StoryblokBridge(e).on(["input", "published", "change"], (s) => {
        s.action === "input" && s.story.id === o ? t(s.story) : (s.action === "change" || s.action === "published") && s.storyId === o && window.location.reload();
      });
    });
  }
}, rt = (o = {}) => {
  const {
    bridge: t,
    accessToken: e,
    use: r = [],
    apiOptions: s = {},
    richText: n = {}
  } = o;
  s.accessToken = s.accessToken || e;
  const a = { bridge: t, apiOptions: s };
  let i = {};
  return r.forEach((c) => {
    i = h(h({}, i), c(a));
  }), t !== !1 && V(tt), m = new R(n.schema), n.resolver && E(m, n.resolver), i;
}, E = (o, t) => {
  o.addNode("blok", (e) => {
    let r = "";
    return e.attrs.body.forEach((s) => {
      r += t(s.component, s);
    }), {
      html: r
    };
  });
}, lt = (o, t) => {
  if (!m) {
    console.error("Please initialize the Storyblok SDK before calling the renderRichText function");
    return;
  }
  if (o === "")
    return "";
  if (!o)
    return console.warn(`${o} is not a valid Richtext object. This might be because the value of the richtext field is empty.
    
  For more info about the richtext object check https://github.com/storyblok/storyblok-js#rendering-rich-text`), "";
  let e = m;
  return t && (e = new R(t.schema), t.resolver && E(e, t.resolver)), e.render(o);
}, st = /* @__PURE__ */ P({
  __name: "StoryblokComponent",
  props: {
    blok: null
  },
  setup(o) {
    return (t, e) => (j(), x(A(o.blok.component), C(M({ ...t.$props, ...t.$attrs })), null, 16));
  }
}), ot = {
  beforeMount(o, t) {
    if (t.value) {
      const e = Z(t.value);
      o.setAttribute("data-blok-c", e["data-blok-c"]), o.setAttribute("data-blok-uid", e["data-blok-uid"]), o.classList.add("storyblok__outline");
    }
  }
}, S = (o) => {
  console.error(`You can't use ${o} if you're not loading apiPlugin. Please provide it on StoryblokVue initialization.
    `);
};
let g = null;
const ct = () => (g || S("useStoryblokApi"), g), ut = async (o, t = {}, e = {}) => {
  const r = N(null);
  if (I(() => {
    r.value && r.value.id && et(
      r.value.id,
      (s) => r.value = s,
      e
    );
  }), g) {
    const { data: s } = await g.get(
      `cdn/stories/${o}`,
      t
    );
    r.value = s.story;
  } else
    S("useStoryblok");
  return r;
}, ht = {
  install(o, t = {}) {
    o.directive("editable", ot), o.component("StoryblokComponent", st);
    const { storyblokApi: e } = rt(t);
    g = e;
  }
};
export {
  Y as RichTextSchema,
  st as StoryblokComponent,
  ht as StoryblokVue,
  at as apiPlugin,
  lt as renderRichText,
  ut as useStoryblok,
  ct as useStoryblokApi,
  et as useStoryblokBridge
};
